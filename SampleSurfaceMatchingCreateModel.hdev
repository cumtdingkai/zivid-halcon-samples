<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.1">
<procedure name="main">
<interface/>
<body>
<c>* Copyright (c) 2019, Zivid AS</c>
<c>* All rights reserved.</c>
<c>* </c>
<c>* Redistribution and use in source and binary forms, with or without</c>
<c>* modification, are permitted provided that the following conditions are</c>
<c>* met:</c>
<c>* </c>
<c>* 1. Redistributions of source code must retain the above copyright</c>
<c>*   notice, this list of conditions and the following disclaimer.</c>
<c>* </c>
<c>* 2. Redistributions in binary form must reproduce the above copyright</c>
<c>*    notice, this list of conditions and the following disclaimer in the</c>
<c>*    documentation and/or other materials provided with the</c>
<c>*    distribution.</c>
<c>* </c>
<c>* 3. Neither the name of Zivid AS nor the names of its contributors may</c>
<c>*    be used to endorse or promote products derived from this software</c>
<c>*    without specific prior written permission.</c>
<c>* </c>
<c>* THIS SOFTWARE IS PROVIDED BY ZIVID AS AND CONTRIBUTORS "AS IS" AND ANY</c>
<c>* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</c>
<c>* IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR</c>
<c>* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ZIVID AS OR CONTRIBUTORS BE</c>
<c>* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</c>
<c>* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</c>
<c>* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</c>
<c>* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</c>
<c>* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE</c>
<c>* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN</c>
<c>* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </c>
<c></c>
<c>* </c>
<c>* Example for the usage of a Zivid 3D camera in HALCON</c>
<c>* </c>
<c>* This example shows how to create a model for HALCON surface-based 3D</c>
<c>* matching algorithm. It should be used together with the</c>
<c>* SampleSurfaceMatchingFindModel.hdev where the model created by this</c>
<c>* program is utilized for surface-based 3D matching algorithm. This</c>
<c>* example comes with HDR settings and other parameters which were used</c>
<c>* to create models of the following three objects: a Twinings tea box,</c>
<c>* a Pringles can (190 g), and a plastic Coca-Cola bottle (0.5 l).</c>
<c>* </c>
<c>* Please note that you first need to install Zivid Software and</c>
<c>* correctly set the environment variables. After this, you can</c>
<c>* access the camera with the HALCON GenICamTL interface.</c>
<c>* </c>
<c></c>
<c>* Connect to the Zivid camera</c>
<l>open_framegrabber ('GenICamTL',1, 1, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', 'default', 'default', 0, 0, AcqHandle)</l>
<c></c>
<c>* Configure 3D-settings</c>
<l>set_framegrabber_param (AcqHandle, 'create_objectmodel3d', 'enable')</l>
<l>set_framegrabber_param (AcqHandle, 'add_objectmodel3d_overlay_attrib', 'enable')</l>
<c></c>
<c>* Set the timeout for aborting a pending grab to infinity; useful for longer exposure times</c>
<l>set_framegrabber_param (AcqHandle, 'grab_timeout', -1)</l>
<c></c>
<c>* Switch to the HDR mode</c>
<l>set_framegrabber_param (AcqHandle, 'AcquisitionMode', 'MergedMultiFrame')</l>
<c></c>
<c>* Reset any previous HDR settings</c>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameReset', 1)</l>
<c></c>
<c>* Configure HDR settings (Twinings tea box)</c>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameMode','HDR')</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameExposureTime',10000)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',22)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',28)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<c></c>
<c>* Configure HDR settings (Pringles can)</c>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameMode','HDR')</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameExposureTime',10000)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',26)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',48)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<c></c>
<c>* Configure HDR settings (Coca-Cola bottle)</c>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameMode','HDR')</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameExposureTime',10000)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',20)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',32)</l>
<l>* set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<c></c>
<c>* Configure HDR settings (Your own object)</c>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameMode','HDR')</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameExposureTime',10000)</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',14)</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',22)</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameIris',40)</l>
<l>set_framegrabber_param (AcqHandle, 'MergedMultiFrameAdd','1')</l>
<c></c>
<c>* Grab the HDR image</c>
<l>grab_data (Image, Region, Contours, AcqHandle, ObjectModel3D_Scene)</l>
<c></c>
<c>* Extract the following images: X, Y, Z, Contrast, and RGB</c>
<l>select_obj (Image, X, 1)</l>
<l>select_obj (Image, Y, 2)</l>
<l>select_obj (Image, Z, 3)</l>
<l>select_obj (Image, Confidence, 4)</l>
<l>select_obj (Image, RGBA, 5)</l>
<c></c>
<c>* Prepare the graphics window</c>
<l>dev_close_window ()</l>
<l>WinWidth := 1920</l>
<l>WinHeight := 1200</l>
<l>dev_open_window (0, 0, WinWidth, WinHeight, 'black', Window3D)</l>
<c></c>
<c>* Display the RGB image</c>
<l>dev_set_window (Window3D)</l>
<l>dev_display (RGBA)</l>
<c></c>
<c>* Use the mouse cursor to draw a region around the object</c>
<l>dev_disp_text (['Position the mouse cursor on the edge of the object', 'Click and hold the left mouse button to begin drawing the ROI around the object', 'Release the left mouse button to end drawing the ROI', 'Click the right mouse button to continue running the program'], 'window', 'bottom', 'left', 'black', [], [])</l>
<l>draw_region (RegionDraw, Window3D)</l>
<c></c>
<c>* Get min and max Z values encapsulated by the created region</c>
<l>min_max_gray (RegionDraw, Z, 0, MinZ, MaxZ, RangeZ)</l>
<c></c>
<c>* Segment the Z image with Z values encapsulated by the created region</c>
<l>threshold (Z, RegionZ, MinZ, MaxZ)</l>
<l>reduce_domain (Z, RegionZ, Z)</l>
<c></c>
<c>* Segment the resulting Z image with the created region</c>
<l>reduce_domain (Z, RegionDraw, Z)</l>
<c></c>
<c>* Transform 3D points from X, Y, Z images to a HALCON 3D object model</c>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel3D)</l>
<c></c>
<c>* Compute normals for the HALCON 3D object model</c>
<l>count_seconds (T0)</l>
<l>sample_object_model_3d(ObjectModel3D,'fast_compute_normals', 1, [], [], ObjectModel3D)</l>
<l>count_seconds (T1)</l>
<l>TimeForSampling := (T1 - T0)</l>
<c></c>
<c>* Create a HALCON surface-based matching model</c>
<l>count_seconds (T0)</l>
<l>create_surface_model (ObjectModel3D, 0.01, [], [], SFM)</l>
<l>count_seconds (T1)</l>
<l>TimeForCreating := (T1 - T0)</l>
<c></c>
<c>* Disconnect from the Zivid Camera</c>
<l>close_framegrabber (AcqHandle)</l>
<c></c>
<c>* Save the HALCON 3D object model</c>
<l>write_object_model_3d(ObjectModel3D, 'om3', 'ObjectModel3D', [], [] )</l>
<c></c>
<c>* Save the HALCON surface-based matching model</c>
<l>write_surface_model(SFM,'SFM')</l>
<c></c>
<c>* Load the HALCON 3D object model</c>
<l>read_object_model_3d( 'ObjectModel3D', 'm', [], [], ObjectModel3D, Status)</l>
<c></c>
<c>* Load the HALCON surface-based matching model</c>
<l>read_surface_model('SFM', SFM)</l>
<c></c>
<c>* Display the 3D color point cloud, press the button to continue</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<l>visualize_object_model_3d (Window3D, ObjectModel3D, [], [], [], [], [], [], [], PoseOut)</l>
<c></c>
<c>* Close the graphics window</c>
<l>dev_set_window (Window3D)</l>
<l>dev_close_window ()</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
